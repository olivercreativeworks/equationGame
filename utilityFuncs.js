"use strict";
// Utility Functions
function dataIsArray(data) {
    if (Array.isArray(data)) {
        return true;
    }
}
function showKeys(obj) {
    const keys = Object.keys(obj);
    return keys;
}
function showValues(obj) {
    const keys = Object.keys(obj);
    let values = [];
    for (let key in keys) {
        values.push(obj[key]);
    }
    return values;
}
function showItems(obj) {
    let keys = showKeys(obj);
    let values = showValues(obj);
    let items = new Object();
    for (let i = 0; i < keys.length; i++) {
        items[keys[i]] = values[i];
    }
    return JSON.stringify(items);
}
/**
 * Returns a random key from an array or dictonary
 * @param {object} options The array or dictionary you want to get a random key from
 * @return {string | number} A random key from the array or dictionary
 */
function randomChoice(options) {
    const optionsKeysList = Object.keys(options);
    const randomIndex = Math.floor(Math.random() * optionsKeysList.length);
    const randomKey = optionsKeysList[randomIndex];
    return options[randomKey];
}
// Create Equation for Game
/**
 * This is the function that creates the equation output for the game
 * @param listOfTerms The array or dictionary of terms you want in your equation
 * @param numberOfTerms The number of terms you want in your equation
 * @param preferredFirstTerms The term you would like your equation to start off with. If this is an array, one of the elements will be selected at random
 * @returns An array with the terms of your randomly generated equation
 */
function createEquation(listOfTerms, numberOfTerms, preferredFirstTerms) {
    if (typeof (numberOfTerms) !== 'number') {
        throw TypeError(`@param numberOfTerms should be type number, not ${typeof (numberOfTerms)}`);
    }
    if (numberOfTerms < 1) {
        throw RangeError('@param numberOfTerms cannot be less than 1');
    }
    let equation = [];
    if (preferredFirstTerms) {
        const firstTerm = randomChoice(preferredFirstTerms);
        equation.push(firstTerm);
    }
    while (equation.length < numberOfTerms) {
        const nextTerm = randomChoice(listOfTerms);
        equation.push(nextTerm);
    }
    return equation;
}
/**
 * This function solves the equation generated by the create equation function. It will apply the logic for + and - signs.
 * @param equation The array containing your equation elements, including + and - signs
 * @returns An array of your equation elements after duplicating elements followed by a + sign and removing elements followed by a - sign
 */
function solveEquation(equation) {
    let solution = equation.reduce((acc, currentValue) => {
        if (currentValue === '-') {
            if (acc.length >= 0) {
                acc.pop();
            }
            return acc;
        }
        if (currentValue === '+') {
            currentValue = acc[acc.length - 1];
        }
        acc.push(currentValue);
        return acc;
    }, []);
    return solution;
}
/**
 * This function simplifies the solution to the equation
 * @param solution An array of your solution to the equation
 * @returns An array that "combines" elements that appear in a row (i.e. [blue, blue, green] >>> [blue, green])
 */
function simplifySolution(solution) {
    let simplifiedSolution = solution.reduce((acc, currentValue) => {
        if (currentValue === acc[acc.length - 1]) {
            acc.pop();
        }
        acc.push(currentValue);
        return acc;
    }, []);
    return simplifiedSolution;
}
// Define equation terms
const operations = {
    '-': '-',
    '+': '+'
};
const colors = {
    0: 'black',
    1: 'white',
    2: 'red',
    3: 'yellow',
    4: 'blue',
    5: 'orange',
    6: 'purple',
    7: 'green'
};
// Print Equation On Screen
// Functions and variables to print
let equation = createEquation(Object.assign(Object.assign({}, colors), operations), 15, colors);
let solution = solveEquation(equation);
let simplifiedSolution = simplifySolution(solution);
function createPalette(paletteItems) {
    let newDivs = [];
    paletteItems.forEach((paletteItem) => {
        let newDiv = document.createElement('div');
        newDiv.classList.add('color', paletteItem);
        if (paletteItem === '-' || paletteItem === '+') {
            newDiv.classList.value = 'operation';
            let newTextNode = document.createTextNode(paletteItem);
            newDiv.appendChild(newTextNode);
        }
        newDivs.push(newDiv);
    });
    return newDivs;
}
function addColorFill() {
    let colorDivs = document.getElementsByClassName('color');
    for (let colorDiv of colorDivs) {
        console.log(colorDiv);
        let divBgColor = colorDiv.classList[1];
        console.log(divBgColor);
        colorDiv.style.background = divBgColor;
    }
}
console.log(equation);
console.log(solution);
console.log(simplifiedSolution);
// Actually printing to screen
const equationDisplayArea = document.getElementById('equation');
const equationPalette = createPalette(equation);
equationPalette.forEach((paletteItem) => {
    equationDisplayArea === null || equationDisplayArea === void 0 ? void 0 : equationDisplayArea.appendChild(paletteItem);
});
// Print player's color palette
const colorsArr = showValues(colors);
const selectionPalette = createPalette(colorsArr);
const selectionDisplayArea = document.getElementById('selectionPalette');
// Add click functionality
function paintAnswerPalette(color) {
    let answerPalette = document.getElementById('answerPalette');
    let answers = createPalette(color);
    answers.forEach((answer) => {
        answer.addEventListener('click', function () {
            answer.remove();
        });
    });
    answers.forEach((answer) => {
        answerPalette === null || answerPalette === void 0 ? void 0 : answerPalette.appendChild(answer);
    });
    addColorFill();
}
selectionPalette.forEach((paletteItem) => {
    paletteItem.addEventListener('click', function (color) {
        let paletteItemColor = color.target.classList[1].split(' ');
        paintAnswerPalette(paletteItemColor);
    });
}, selectionPalette.forEach((paletteItem) => {
    selectionDisplayArea === null || selectionDisplayArea === void 0 ? void 0 : selectionDisplayArea.appendChild(paletteItem);
})
// Compare answer palette with the simplified solution
// 
//   let answerPalette = document.getElementById('answerPalette')
//   let answerArray:any[] = []
//   Array.from(answerPalette?.children).forEach((child) => {
//    let childColor = child.classList[1]
//    console.log(childColor)
//    answerArray.push(childColor)
//   })
//   console.log(`answerArray: ${answerArray}`)
//   console.log(`solution: ${solution}`)
//   if (answerArray != solution) {
//    console.log('Success!')
//   }
//  })
// console.log(`simplifiedSolution: ${simplifiedSolution}, ${Array.isArray(simplifiedSolution)}`)
// Add color fill
, 
// Compare answer palette with the simplified solution
// 
//   let answerPalette = document.getElementById('answerPalette')
//   let answerArray:any[] = []
//   Array.from(answerPalette?.children).forEach((child) => {
//    let childColor = child.classList[1]
//    console.log(childColor)
//    answerArray.push(childColor)
//   })
//   console.log(`answerArray: ${answerArray}`)
//   console.log(`solution: ${solution}`)
//   if (answerArray != solution) {
//    console.log('Success!')
//   }
//  })
// console.log(`simplifiedSolution: ${simplifiedSolution}, ${Array.isArray(simplifiedSolution)}`)
// Add color fill
addColorFill());
