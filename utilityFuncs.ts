// Utility Functions

function dataIsArray(data:any) {
 if (Array.isArray(data)) {
  return true
 }
}

function showKeys(obj:any) {
 const keys = Object.keys(obj)
 return keys
}

function showValues(obj:any) {
 const keys = Object.keys(obj)
 let values = []
 for (let key in keys) {
  values.push(obj[key])
 }
 return values
}

function showItems(obj: any) {
 let keys = showKeys(obj)
 let values = showValues(obj)
 let items = new Object();
 for (let i = 0; i < keys.length; i++) {
  items[keys[i]] = values[i]
 }
 return JSON.stringify(items)
}

/**
 * Returns a random key from an array or dictonary
 * @param {object} options The array or dictionary you want to get a random key from
 * @return {string | number} A random key from the array or dictionary 
 */
function randomChoice(options:object) {
 const optionsKeysList = Object.keys(options)
 const randomIndex = Math.floor(Math.random() * optionsKeysList.length)
 const randomKey = optionsKeysList[randomIndex]
 return options[randomKey]
}

// Create Equation for Game
/**
 * This is the function that creates the equation output for the game
 * @param listOfTerms The array or dictionary of terms you want in your equation
 * @param numberOfTerms The number of terms you want in your equation
 * @param preferredFirstTerms The term you would like your equation to start off with. If this is an array, one of the elements will be selected at random
 * @returns An array with the terms of your randomly generated equation
 */
function createEquation( listOfTerms:object, numberOfTerms:number, preferredFirstTerms?:object) {
 if (typeof (numberOfTerms) !== 'number') {
  throw TypeError(`@param numberOfTerms should be type number, not ${typeof(numberOfTerms)}`)
 }
 if (numberOfTerms < 1) {
  throw RangeError('@param numberOfTerms cannot be less than 1')
 }
 let equation = [];
 if (preferredFirstTerms) {
  const firstTerm = randomChoice(preferredFirstTerms)
  equation.push(firstTerm)
  }
 while (equation.length < numberOfTerms) {
  const nextTerm = randomChoice(listOfTerms)
  equation.push(nextTerm)
 }
 return equation
}

/**
 * This function solves the equation generated by the create equation function. It will apply the logic for + and - signs.
 * @param equation The array containing your equation elements, including + and - signs
 * @returns An array of your equation elements after duplicating elements followed by a + sign and removing elements followed by a - sign
 */
function solveEquation(equation: any[]) {
 let solution = equation.reduce((acc, currentValue) => {
  if (currentValue === '-') {
   if (acc.length >= 0) {
    acc.pop()    
   }
   return acc
  }
 
  if (currentValue === '+') {
   currentValue = acc[acc.length-1]
  }

  acc.push(currentValue)
  return acc
 }, [])
 return solution
}

/**
 * This function simplifies the solution to the equation
 * @param solution An array of your solution to the equation
 * @returns An array that "combines" elements that appear in a row (i.e. [blue, blue, green] >>> [blue, green])
 */
function simplifySolution(solution:any[]) {
 let simplifiedSolution = solution.reduce((acc, currentValue) => {
  if (currentValue === acc[acc.length - 1]) {
   acc.pop()
  }
  acc.push(currentValue)
  return acc
 }, [])
 return simplifiedSolution
}

// Define equation terms
const operations: object = {
 '-': '-',
 '+': '+'
}

const colors:object = {
 0: 'black',
 1: 'white',
 2: 'red',
 3: 'yellow',
 4: 'blue',
 5: 'orange',
 6: 'purple',
 7: 'green'
}

// Print Equation On Screen

// Functions and variables to print
let equation = createEquation({ ...colors, ...operations }, 15, colors)
let solution = solveEquation(equation)
let simplifiedSolution = simplifySolution(solution)

function createPalette(paletteItems:any[]) {
 let newDivs: any[] = []
 
 paletteItems.forEach((paletteItem) => {
  let newDiv = document.createElement('div');
  newDiv.classList.add('color', paletteItem)
  if (paletteItem === '-' || paletteItem === '+') {
   newDiv.classList.value = 'operation'
   let newTextNode = document.createTextNode(paletteItem)
   newDiv.appendChild(newTextNode)
  }
  newDivs.push(newDiv)
 })
 return newDivs
}

function addColorFill() {
 let colorDivs = document.getElementsByClassName('color')
 for (let colorDiv of colorDivs) {
  console.log(colorDiv)
  let divBgColor = colorDiv.classList[1]
  console.log(divBgColor)
  colorDiv.style.background = divBgColor
 }
}

console.log(equation)
console.log(solution)
console.log(simplifiedSolution)

// Actually printing to screen
const equationDisplayArea = document.getElementById('equation')

const equationPalette = createPalette(equation)
equationPalette.forEach((paletteItem) => {
 equationDisplayArea?.appendChild(paletteItem) 
})


// Print player's color palette
const colorsArr = showValues(colors)
const selectionPalette = createPalette(colorsArr)
const selectionDisplayArea = document.getElementById('selectionPalette')

// Add click functionality
function paintAnswerPalette(color:any[]) {
 let answerPalette = document.getElementById('answerPalette')
 let answers = createPalette(color)

 answers.forEach((answer) => {
  answer.addEventListener('click', function () {
   answer.remove()
  })
 })

 answers.forEach((answer) => {
  answerPalette?.appendChild(answer)
 })

 addColorFill()
}

selectionPalette.forEach((paletteItem) => {
 paletteItem.addEventListener('click', function (color: any) {
  let paletteItemColor = color.target.classList[1].split(' ')
  paintAnswerPalette(paletteItemColor)
 })
}

selectionPalette.forEach((paletteItem) => {
 selectionDisplayArea?.appendChild(paletteItem)
})


// Compare answer palette with the simplified solution
// 
//   let answerPalette = document.getElementById('answerPalette')
//   let answerArray:any[] = []
//   Array.from(answerPalette?.children).forEach((child) => {
//    let childColor = child.classList[1]
//    console.log(childColor)
//    answerArray.push(childColor)
//   })
//   console.log(`answerArray: ${answerArray}`)
//   console.log(`solution: ${solution}`)
//   if (answerArray != solution) {
//    console.log('Success!')
//   }
//  })
// console.log(`simplifiedSolution: ${simplifiedSolution}, ${Array.isArray(simplifiedSolution)}`)


// Add color fill
addColorFill()
